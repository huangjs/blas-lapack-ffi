{
hunk ./src/enc-unicode.lisp 709
-     (let ((reverse nil))
-       (when (and (not (zerop (- end start)))
-                  (case (,getter src 0 4)
-                    (#.+byte-order-mark-code+ t)
-                    (#.+swapped-byte-order-mark-code-32+
-                     (setq reverse t) t)))
-         (incf start 4))
-      (loop for i fixnum from start below end by 4
-            for di from d-start do
-            (,setter (let ((unit (if reverse
-                                     (,getter src i 4 :re)
-                                     (,getter src i 4))))
-                       (if (>= unit #x110000)
-                           (decoding-error (vector (,getter src i)
-                                                   (,getter src (+ i 1))
-                                                   (,getter src (+ i 2))
-                                                   (,getter src (+ i 3)))
-                                           :utf-32 src i +repl+
-                                           'character-out-of-range)
-                           unit))
-                     dest di)
-            finally (return (the fixnum (- di d-start)))))))
+     (let ((reverse #+big-endian nil #+little-endian t))
+       (when (not (zerop (- end start)))
+         (case (,getter src 0 4)
+           (#.+byte-order-mark-code+
+              (incf start 4)
+              #+little-endian (setq reverse nil))
+           (#.+swapped-byte-order-mark-code-32+
+              (incf start 4)
+              #+big-endian (setq reverse t))))
+       (loop for i fixnum from start below end by 4
+             for di from d-start
+             do (,setter (let ((unit (if reverse
+                                         (,getter src i 4 :re)
+                                         (,getter src i 4))))
+                           (if (>= unit #x110000)
+                               (decoding-error (vector (,getter src i)
+                                                       (,getter src (+ i 1))
+                                                       (,getter src (+ i 2))
+                                                       (,getter src (+ i 3)))
+                                               :utf-32 src i +repl+
+                                               'character-out-of-range)
+                               unit))
+                         dest di)
+             finally (return (the fixnum (- di d-start)))))))
hunk ./tests/tests.lisp 167
+
+;;;; UTF-32
+
+;;; RT: check that UTF-32 characters without a BOM are treated as
+;;; little-endian.
+(deftest endianness.utf-32.no-bom ()
+  (is (string= "a" (octets-to-string (ub8v 0 0 0 97) :encoding :utf-32))))
hunk ./tests/tests.lisp 55
-(defmacro signals* (form &body clauses)
-  `(handler-case ,form
-     ,@clauses
-     (:no-error (result)
-       (declare (ignore result))
-       ;; it'd be nice if the failture described what FORM returned.
-       (stefil::record-failure 'stefil::missing-condition
-                               :form ',form
-                               :condition ',(mapcar #'car clauses)))))
-
hunk ./tests/tests.lisp 130
-#+lispworks
-(pushnew 'dec.utf-8.1 rtest::*expected-failures*)
+;; #+lispworks
+;; (pushnew 'dec.utf-8.1 rtest::*expected-failures*)
hunk ./tests/tests.lisp 143
-      (is (eq :utf-8(character-coding-error-encoding c))))
+      (is (eq :utf-8 (character-coding-error-encoding c))))
hunk ./babel.asd 30
-  :version "0.2.0"
+  :version "0.3.0"
hunk ./src/strings.lisp 285
-      (let ((enc (get-character-encoding encoding)))
+      (let ((enc (typecase encoding
+                   (external-format (external-format-encoding encoding))
+                   (t (get-character-encoding encoding)))))
hunk ./src/strings.lisp 254
-;;; In the these 4 functions below, ERRORP defaults to NIL.  But it
-;;; might as well default to T.  TODO: find out a good reason to go
-;;; either way.
-;;;
hunk ./src/strings.lisp 273
+        ;; TODO we could optimize ASCII here: the result should
+        ;; be a simple-base-string filled using code-char...
hunk ./src/strings.lisp 120
-(defun lookup-string-vector-mapping (encoding)
-  (lookup-mapping *string-vector-mappings* encoding))
+(defparameter *simple-base-string-vector-mappings*
+  (instantiate-concrete-mappings
+   ;; :optimize ((speed 3) (safety 0) (debug 0) (compilation-speed 0))
+   :octet-seq-setter ub-set
+   :octet-seq-getter ub-get
+   :octet-seq-type (simple-array (unsigned-byte 8) (*))
+   :code-point-seq-setter string-set
+   :code-point-seq-getter string-get
+   :code-point-seq-type simple-base-string))
hunk ./src/strings.lisp 277
-          (mapping (lookup-string-vector-mapping encoding)))
+          (mapping (lookup-mapping *string-vector-mappings* encoding)))
hunk ./src/strings.lisp 298
-;;; FIXME: we shouldn't really need that coercion to UNICODE-STRING
-;;; but we kind of because it's declared all over.  To avoid that,
-;;; we'd need different types for input and output strings.  Or maybe
-;;; this is not a problem; figure that out.
hunk ./src/strings.lisp 301
-  (check-type string string)
-  (with-checked-simple-vector ((string (coerce string 'unicode-string))
-                               (start start) (end end))
-    (declare (type simple-unicode-string string))
-    (let* ((*suppress-character-coding-errors* (not errorp))
-           (mapping (lookup-string-vector-mapping encoding))
-           (bom (bom-vector encoding use-bom))
-           (vector (make-array (the array-index
-                                 (+ (funcall (octet-counter mapping)
-                                             string start end -1)
-                                    (length bom)))
-                               :element-type '(unsigned-byte 8))))
-      (replace vector bom)
-      (funcall (encoder mapping) string start end vector (length bom))
-      vector)))
+  (declare (optimize (speed 3) (safety 2)))
+  (let ((*suppress-character-coding-errors* (not errorp)))
+    (etypecase string
+      (simple-base-string
+       (unless end
+         (setf end (length string)))
+       (check-vector-bounds string start end)
+       (let* ((mapping (lookup-mapping *simple-base-string-vector-mappings*
+                                       encoding))
+              (bom (bom-vector encoding use-bom))
+              (bom-length (length bom))
+              (result (make-array (+ (length string) bom-length)
+                                  :element-type '(unsigned-byte 8))))
+         (replace result bom)
+         (funcall (the function (encoder mapping))
+                  string start end result bom-length)
+         result))
+      (string
+       ;; FIXME: we shouldn't really need that coercion to UNICODE-STRING
+       ;; but we kind of because it's declared all over.  To avoid that,
+       ;; we'd need different types for input and output strings.  Or maybe
+       ;; this is not a problem; figure that out.
+       (with-checked-simple-vector ((string (coerce string 'unicode-string))
+                                    (start start) (end end))
+         (declare (type simple-unicode-string string))
+         (let* ((mapping (lookup-mapping *string-vector-mappings* encoding))
+                (bom (bom-vector encoding use-bom))
+                (bom-length (length bom))
+                (result (make-array (+ (the array-index
+                                         (funcall (the function (octet-counter mapping))
+                                                  string start end -1))
+                                       bom-length)
+                                    :element-type '(unsigned-byte 8))))
+           (replace result bom)
+           (funcall (the function (encoder mapping))
+                    string start end result bom-length)
+           result))))))
hunk ./src/strings.lisp 372
-    (let ((mapping (lookup-string-vector-mapping encoding))
+    (let ((mapping (lookup-mapping *string-vector-mappings* encoding))
hunk ./src/strings.lisp 383
-    (let ((mapping (lookup-string-vector-mapping encoding))
+    (let ((mapping (lookup-mapping *string-vector-mappings* encoding))
hunk ./src/encodings.lisp 129
-(defun 8-bit-fixed-width-counter (getter type)
+(defun make-8-bit-fixed-width-counter (getter type)
hunk ./src/encodings.lisp 131
-  `(lambda (seq start end max)
+  `(named-lambda 8-bit-fixed-width-counter (seq start end max)
hunk ./src/encodings.lisp 140
-(defun dummy-coder (sg st ds dt)
+(defun make-dummy-coder (sg st ds dt)
hunk ./src/encodings.lisp 142
-  `(lambda (src s e dest i)
+  `(named-lambda dummy-coder (src s e dest i)
hunk ./src/encodings.lisp 147
-  ((encoder :accessor encoder :initform #'dummy-coder)
-   (decoder :accessor decoder :initform #'dummy-coder)
+  ((encoder :accessor encoder :initform 'make-dummy-coder)
+   (decoder :accessor decoder :initform 'make-dummy-coder)
hunk ./src/encodings.lisp 150
-    :accessor octet-counter :initform #'8-bit-fixed-width-counter)
+    :accessor octet-counter :initform 'make-8-bit-fixed-width-counter)
hunk ./src/encodings.lisp 152
-    :accessor code-point-counter :initform #'8-bit-fixed-width-counter)))
+    :accessor code-point-counter :initform 'make-8-bit-fixed-width-counter)))
hunk ./src/encodings.lisp 146
-(defclass mapping ()
-  ((encoder :accessor encoder :initform 'make-dummy-coder)
-   (decoder :accessor decoder :initform 'make-dummy-coder)
-   (octet-counter
-    :accessor octet-counter :initform 'make-8-bit-fixed-width-counter)
-   (code-point-counter
-    :accessor code-point-counter :initform 'make-8-bit-fixed-width-counter)))
-
hunk ./src/encodings.lisp 153
-(defclass abstract-mapping (mapping) ())
+(defclass abstract-mapping ()
+  ((encoder-factory :accessor encoder-factory :initform 'make-dummy-coder)
+   (decoder-factory :accessor decoder-factory :initform 'make-dummy-coder)
+   (octet-counter-factory :accessor octet-counter-factory
+                          :initform 'make-8-bit-fixed-width-counter)
+   (code-point-counter-factory :accessor code-point-counter-factory
+                               :initform 'make-8-bit-fixed-width-counter)))
hunk ./src/encodings.lisp 170
-(defclass concrete-mapping (mapping) ())
+(defclass concrete-mapping ()
+  ((encoder :accessor encoder)
+   (decoder :accessor decoder)
+   (octet-counter :accessor octet-counter)
+   (code-point-counter :accessor code-point-counter)))
hunk ./src/encodings.lisp 176
-(defvar *abstract-mappings* (make-hash-table :test 'eq))
+(defparameter *abstract-mappings* (make-hash-table :test 'eq))
hunk ./src/encodings.lisp 184
-(defun register-mapping (encoding slot-name fn)
-  (let ((m (get-abstract-mapping encoding)))
-    (when (null m)
-      (setq m (make-instance 'abstract-mapping))
-      (setf (get-abstract-mapping encoding) m))
-    (setf (slot-value m slot-name) fn)))
+(defun %register-mapping-part (encoding slot-name fn)
+  (let ((mapping (get-abstract-mapping encoding)))
+    (unless mapping
+      (setq mapping (make-instance 'abstract-mapping))
+      (setf (get-abstract-mapping encoding) mapping))
+    (setf (slot-value mapping slot-name) fn)))
hunk ./src/encodings.lisp 194
-  `(register-mapping ,encoding 'encoder (lambda (,sa ,st ,da ,dt) ,@body)))
+  `(%register-mapping-part ,encoding 'encoder-factory
+                           (named-lambda encoder (,sa ,st ,da ,dt)
+                             ,@body)))
hunk ./src/encodings.lisp 199
-  `(register-mapping ,encoding 'decoder (lambda (,sa ,st ,da ,dt) ,@body)))
+  `(%register-mapping-part ,encoding 'decoder-factory
+                           (named-lambda decoder (,sa ,st ,da ,dt)
+                             ,@body)))
hunk ./src/encodings.lisp 204
-  `(register-mapping ,encoding 'octet-counter (lambda (,acc ,type) ,@body)))
+  `(%register-mapping-part ,encoding 'octet-counter-factory
+                           (named-lambda octet-counter-factory (,acc ,type)
+                             ,@body)))
hunk ./src/encodings.lisp 209
-  `(register-mapping
-    ,encoding 'code-point-counter (lambda (,acc ,type) ,@body)))
+  `(%register-mapping-part ,encoding 'code-point-counter-factory
+                           (named-lambda code-point-counter (,acc ,type)
+                             ,@body)))
hunk ./src/encodings.lisp 217
-(defun %am-to-cm (cm am osg oss ost cpsg cpss cpst)
-  `(setf (encoder ,cm) ,(funcall (encoder am) cpsg cpst oss ost)
-         (decoder ,cm) ,(funcall (decoder am) osg ost cpss cpst)
-         (code-point-counter ,cm) ,(funcall (code-point-counter am) osg ost)
-         (octet-counter ,cm) ,(funcall (octet-counter am) cpsg cpst)))
+(defun instantiate-concrete-mapping (am osg oss ost cpsg cpss cpst)
+  `(let ((cm (make-instance 'concrete-mapping)))
+     (setf (encoder cm) ,(funcall (encoder-factory am) cpsg cpst oss ost)
+           (decoder cm) ,(funcall (decoder-factory am) osg ost cpss cpst)
+           (code-point-counter cm) ,(funcall (code-point-counter-factory am)
+                                              osg ost)
+           (octet-counter cm) ,(funcall (octet-counter-factory am) cpsg cpst))
+     cm))
hunk ./src/encodings.lisp 241
-               `(let ((cm (make-instance 'concrete-mapping)))
-                  ,(%am-to-cm 'cm am octet-seq-getter octet-seq-setter
-                              octet-seq-type code-point-seq-getter
-                              code-point-seq-setter code-point-seq-type)
-                  (notice-mapping ,enc cm))))
+              `(let ((cm ,(instantiate-concrete-mapping
+                           am octet-seq-getter octet-seq-setter
+                           octet-seq-type code-point-seq-getter
+                           code-point-seq-setter code-point-seq-type)))
+                 (notice-mapping ,enc cm))))
hunk ./src/strings.lisp 148
-               `(let ((cm (make-instance 'babel-encodings::concrete-mapping)))
-                  ,(babel-encodings::%am-to-cm
-                    'cm am octet-seq-getter octet-seq-setter
-                    octet-seq-type code-pointer-seq-getter
-                    code-point-seq-setter code-point-seq-type)
+               `(let ((cm ,(babel-encodings::instantiate-concrete-mapping
+                            am octet-seq-getter octet-seq-setter
+                            octet-seq-type code-pointer-seq-getter
+                            code-point-seq-setter code-point-seq-type)))
hunk ./src/strings.lisp 173
-                `(let ((cm (make-instance 'babel-encodings::concrete-mapping)))
-                   ,(babel-encodings::%am-to-cm
-                     'cm am octet-seq-getter octet-seq-setter
-                     octet-seq-type code-pointer-seq-getter
-                     code-point-seq-setter code-point-seq-type)
+                `(let ((cm ,(babel-encodings::instantiate-concrete-mapping
+                             am octet-seq-getter octet-seq-setter
+                             octet-seq-type code-pointer-seq-getter
+                             code-point-seq-setter code-point-seq-type)))
hunk ./src/enc-ebcdic.lisp 33
-(declaim (type (simple-array (unsigned-byte 8) (256)) *ebcdic-decode-table*))
-(defparameter *ebcdic-decode-table*
+(define-constant +ebcdic-decode-table+
hunk ./src/enc-ebcdic.lisp 54
-     #xdc #xd9 #xda #x9f)))
+     #xdc #xd9 #xda #x9f))
+  :test #'equalp)
hunk ./src/enc-ebcdic.lisp 57
-(declaim (type (simple-array (unsigned-byte 8) (256)) *ebcdic-encode-table*))
-(defparameter *ebcdic-encode-table*
+(define-constant +ebcdic-encode-table+
hunk ./src/enc-ebcdic.lisp 59
-        for code across *ebcdic-decode-table* for i from 0 do
+        for code across +ebcdic-decode-table+ for i from 0 do
hunk ./src/enc-ebcdic.lisp 62
-        finally (return rt)))
+        finally (return rt))
+  :test #'equalp)
hunk ./src/enc-ebcdic.lisp 68
-      (aref *ebcdic-encode-table* code)))
+      (aref +ebcdic-encode-table+ code)))
hunk ./src/enc-ebcdic.lisp 71
-  (aref *ebcdic-decode-table* octet))
+  (aref +ebcdic-decode-table+ octet))
hunk ./src/enc-unicode.lisp 70
-  `(lambda (seq start end max)
+  `(named-lambda utf-8-octet-counter (seq start end max)
hunk ./src/enc-unicode.lisp 86
-  `(lambda (seq start end max)
+  `(named-lambda utf-8-code-point-counter (seq start end max)
hunk ./src/enc-unicode.lisp 131
-  `(lambda (src start end dest d-start)
+  `(named-lambda utf-8-encoder (src start end dest d-start)
hunk ./src/enc-unicode.lisp 166
-  `(lambda (src start end dest d-start)
+  `(named-lambda utf-8-decoder (src start end dest d-start)
hunk ./src/enc-unicode.lisp 319
-  `(lambda (seq start end max)
+  `(named-lambda utf-8b-octet-counter (seq start end max)
hunk ./src/enc-unicode.lisp 336
-  `(lambda (seq start end max)
+  `(named-lambda utf-8b-code-point-counter (seq start end max)
hunk ./src/enc-unicode.lisp 387
-  `(lambda (src start end dest d-start)
+  `(named-lambda utf-8b-encoder (src start end dest d-start)
hunk ./src/enc-unicode.lisp 426
-  `(lambda (src start end dest d-start)
+  `(named-lambda utf-8b-decoder (src start end dest d-start)
hunk ./src/enc-unicode.lisp 497
-  `(lambda (seq start end max)
+  `(named-lambda utf-16-octet-counter (seq start end max)
hunk ./src/enc-unicode.lisp 541
-  `(lambda (seq start end max)
+  `(named-lambda utf-16-code-point-counter (seq start end max)
hunk ./src/enc-unicode.lisp 574
-  `(lambda (src start end dest d-start)
+  `(named-lambda utf-16-encoder (src start end dest d-start)
hunk ./src/enc-unicode.lisp 593
-  `(lambda (src start end dest d-start)
+  `(named-lambda utf-16-decoder (src start end dest d-start)
hunk ./src/enc-unicode.lisp 638
-  `(lambda (seq start end max)
+  `(named-lambda utf-32-octet-counter (seq start end max)
hunk ./src/enc-unicode.lisp 670
-  `(lambda (seq start end max)
+  `(named-lambda utf-32-code-point-counter (seq start end max)
hunk ./src/enc-unicode.lisp 695
-  `(lambda (src start end dest d-start)
+  `(named-lambda utf-32-encoder (src start end dest d-start)
hunk ./src/enc-unicode.lisp 705
-  `(lambda (src start end dest d-start)
+  `(named-lambda utf-32-decoder (src start end dest d-start)
hunk ./src/encodings.lisp 271
-       `(lambda (,',src ,',start ,',end ,',dest ,',d-start)
+       `(named-lambda ,',(symbolicate encoding '#:-unibyte-encoder)
+            (,',src ,',start ,',end ,',dest ,',d-start)
hunk ./src/encodings.lisp 295
-       `(lambda (,',src ,',start ,',end ,',dest ,',d-start)
+       `(named-lambda ,',(symbolicate encoding '#:-unibyte-encoder)
+            (,',src ,',start ,',end ,',dest ,',d-start)
hunk ./src/strings.lisp 266
-                 vector-size-in-chars concatenate-strings-to-octets))
+                 vector-size-in-chars concatenate-strings-to-octets
+                 bom-vector))
hunk ./src/strings.lisp 287
-  (if (null use-bom)
-      #()
-      (let ((enc (typecase encoding
-                   (external-format (external-format-encoding encoding))
-                   (t (get-character-encoding encoding)))))
-        (if (or (eq use-bom t)
-                (and (eq use-bom :default) (enc-use-bom enc)))
-            (enc-bom-encoding enc)
-            #()))))
+  (the simple-vector
+    (if (null use-bom)
+        #()
+        (let ((enc (typecase encoding
+                     (external-format (external-format-encoding encoding))
+                     (t (get-character-encoding encoding)))))
+          (if (or (eq use-bom t)
+                  (and (eq use-bom :default) (enc-use-bom enc)))
+              (enc-bom-encoding enc)
+              #())))))
hunk ./tests/tests.lisp 35
-(in-root-suite)
-(defsuite* babel-tests)
+(defsuite* (babel-tests :in root-suite))
hunk ./src/encodings.lisp 213
-;;; Funcalls (at macro-expansion time) the abstract mappings with the
-;;; src/dest accessors and types which generate the appropriate code
-;;; for the concrete mappings.  These functions are then saved in
-;;; their respective slots of the CONCRETE-MAPPING object.
-(defun instantiate-concrete-mapping (am osg oss ost cpsg cpss cpst)
-  `(let ((cm (make-instance 'concrete-mapping)))
-     (setf (encoder cm) ,(funcall (encoder-factory am) cpsg cpst oss ost)
-           (decoder cm) ,(funcall (decoder-factory am) osg ost cpss cpst)
-           (code-point-counter cm) ,(funcall (code-point-counter-factory am)
-                                              osg ost)
-           (octet-counter cm) ,(funcall (octet-counter-factory am) cpsg cpst))
-     cm))
+(defun instantiate-encoder (encoding am octet-seq-getter octet-seq-type
+                            code-point-seq-setter code-point-seq-type)
+  (declare (ignore encoding))
+  (funcall (encoder-factory am)
+           octet-seq-getter
+           octet-seq-type
+           code-point-seq-setter
+           code-point-seq-type))
+
+(defun instantiate-decoder (encoding am octet-seq-getter octet-seq-type
+                            code-point-seq-setter code-point-seq-type)
+  (declare (ignore encoding))
+  (funcall (decoder-factory am)
+           octet-seq-getter
+           octet-seq-type
+           code-point-seq-setter
+           code-point-seq-type))
+
+(defun instantiate-code-point-counter (encoding am octet-seq-getter
+                                       octet-seq-type)
+  (declare (ignore encoding))
+  (funcall (code-point-counter-factory am)
+           octet-seq-getter
+           octet-seq-type))
+
+(defun instantiate-octet-counter (encoding am code-point-seq-getter
+                                  code-point-seq-type)
+  (funcall (octet-counter-factory am)
+           code-point-seq-getter
+           code-point-seq-type))
hunk ./src/encodings.lisp 248
+;;;
+;;; For each encoding funcall the abstract mappings at macro-expansion
+;;; time with the src/dest accessors and types to generate the
+;;; appropriate code for the concrete mappings. These functions are
+;;; then saved in their respective slots of the CONCRETE-MAPPING
+;;; object.
hunk ./src/encodings.lisp 255
-    (&key optimize octet-seq-getter octet-seq-setter octet-seq-type
-     code-point-seq-getter code-point-seq-setter code-point-seq-type)
-  `(let ((ht (make-hash-table :test 'eq)))
-     (declare (optimize ,@optimize))
-     (flet ((notice-mapping (enc-name cm)
-              (let ((aliases (enc-aliases (get-character-encoding enc-name))))
-                (dolist (kw (cons enc-name aliases))
-                  (setf (gethash kw ht) cm)))))
-       ,@(loop for am being the hash-values of *abstract-mappings*
-               using (hash-key enc) collect
-              `(let ((cm ,(instantiate-concrete-mapping
-                           am octet-seq-getter octet-seq-setter
-                           octet-seq-type code-point-seq-getter
-                           code-point-seq-setter code-point-seq-type)))
-                 (notice-mapping ,enc cm))))
-      ht))
+    (&key (encodings (hash-table-keys *abstract-mappings*))
+     (optimize '((speed 3) (debug 0) (compilation-speed 0)))
+     octet-seq-getter octet-seq-setter octet-seq-type
+     code-point-seq-getter code-point-seq-setter code-point-seq-type
+     (instantiate-decoders t))
+  `(locally (declare #+sbcl(sb-ext:muffle-conditions sb-ext:compiler-note))
+     (let ((ht (make-hash-table :test 'eq)))
+       (declare (optimize ,@optimize))
+       (flet ((notice-mapping (encoding-name cm)
+                (let* ((encoding (get-character-encoding encoding-name))
+                       (aliases (enc-aliases encoding)))
+                  (dolist (kw (cons (enc-name encoding) aliases))
+                    (setf (gethash kw ht) cm)))))
+         ,@(loop
+              :for encoding-name :in encodings
+              :for encoding = (get-character-encoding encoding-name)
+              :for am = (gethash encoding-name *abstract-mappings*)
+              :collect
+              `(let ((cm (make-instance 'concrete-mapping)))
+                 (setf (encoder cm)
+                       ,(instantiate-encoder encoding am
+                                             code-point-seq-getter
+                                             code-point-seq-type
+                                             octet-seq-setter
+                                             octet-seq-type))
+                 ,(when instantiate-decoders
+                        `(progn
+                           (setf (decoder cm)
+                                 ,(instantiate-decoder encoding am
+                                                       octet-seq-getter
+                                                       octet-seq-type
+                                                       code-point-seq-setter
+                                                       code-point-seq-type))
+                           (setf (code-point-counter cm)
+                                 ,(instantiate-code-point-counter encoding am
+                                                                  octet-seq-getter
+                                                                  octet-seq-type))))
+                 (setf (octet-counter cm)
+                       ,(instantiate-octet-counter encoding am
+                                                   code-point-seq-getter
+                                                   code-point-seq-type))
+                 (notice-mapping ,encoding-name cm))))
+       ht)))
+
+;;; debugging stuff
+
+#-(and)
+(defun pprint-instantiate-concrete-mappings
+    (&key (encodings (hash-table-keys *abstract-mappings*))
+     (optimize '((debug 3) (safety 3)))
+     (octet-seq-setter 'ub-set) (octet-seq-getter 'ub-get)
+     (octet-seq-type '(simple-array (unsigned-byte 8) (*)))
+     (code-point-seq-setter 'string-set)
+     (code-point-seq-getter 'string-get)
+     (code-point-seq-type 'simple-unicode-string))
+  (let ((encodings (ensure-list encodings))
+        (*package* (find-package :babel-encodings))
+        (*print-case* :downcase))
+    (pprint
+     (macroexpand
+      `(instantiate-concrete-mappings
+        :encodings ,encodings
+        :optimize ,optimize
+        :octet-seq-getter ,octet-seq-getter
+        :octet-seq-setter ,octet-seq-setter
+        :octet-seq-type ,octet-seq-type
+        :code-point-seq-getter ,code-point-seq-getter
+        :code-point-seq-setter ,code-point-seq-setter
+        :code-point-seq-type ,code-point-seq-type))))
+  (values))
hunk ./src/strings.lisp 123
+   :instantiate-decoders nil
hunk ./src/strings.lisp 131
-;;; debugging stuff, TODO: refactor
-
-#-(and)
-(defmacro recompile-mappings (encodings &key (optimize '((debug 3) (safety 3)))
-                              (hash-table-place '*string-vector-mappings*)
-                              (octet-seq-setter 'ub-set)
-                              (octet-seq-getter 'ub-get)
-                              (octet-seq-type
-                               '(simple-array (unsigned-byte 8) (*)))
-                              (code-point-seq-setter 'string-set)
-                              (code-pointer-seq-getter 'string-get)
-                              (code-point-seq-type 'simple-unicode-string))
-  (let ((encodings (ensure-list encodings)))
-    `(locally
-         (declare (optimize ,@optimize))
-       ,@(loop for enc in encodings
-               for am = (gethash enc babel-encodings::*abstract-mappings*)
-               collect
-               `(let ((cm ,(babel-encodings::instantiate-concrete-mapping
-                            am octet-seq-getter octet-seq-setter
-                            octet-seq-type code-pointer-seq-getter
-                            code-point-seq-setter code-point-seq-type)))
-                  (setf (gethash ,enc ,hash-table-place) cm)))
-       (values))))
-
-#-(and)
-(defun debug-mappings (encodings &key (optimize '((debug 3) (safety 3)))
-                       (hash-table-place '*string-vector-mappings*)
-                       (octet-seq-setter 'ub-set) (octet-seq-getter 'ub-get)
-                       (octet-seq-type '(simple-array (unsigned-byte 8) (*)))
-                       (code-point-seq-setter 'string-set)
-                       (code-pointer-seq-getter 'string-get)
-                       (code-point-seq-type 'simple-unicode-string))
-  (let ((encodings (ensure-list encodings))
-        (*package* (find-package :babel-encodings))
-        (*print-case* :downcase))
-    (pprint
-     `(locally
-          (declare (optimize ,@optimize))
-        (setf ,hash-table-place (make-hash-table :test 'eq))
-        ,@(loop for enc in encodings
-                for am = (gethash enc babel-encodings::*abstract-mappings*)
-                collect
-                `(let ((cm ,(babel-encodings::instantiate-concrete-mapping
-                             am octet-seq-getter octet-seq-setter
-                             octet-seq-type code-pointer-seq-getter
-                             code-point-seq-setter code-point-seq-type)))
-                   (setf (gethash ,enc ,hash-table-place) cm))))))
-  (values))
-
hunk ./src/enc-unicode.lisp 636
-(defmacro utf32-octet-counter (getter type)
-  (declare (ignore getter type))
-  `(named-lambda utf-32-octet-counter (seq start end max)
-     (declare  (ignore seq) (fixnum start end max))
-     ;; XXX: the result can be bigger than a fixnum and we don't want
-     ;; that to happen.  Possible solution: signal a warning (hmm,
-     ;; make that an actual error) and truncate.
-     (if (plusp max)
-         (let ((count (the fixnum (min (floor max 4) (- end start)))))
-           (values (the fixnum (* 4 count)) (the fixnum (+ start count))))
-         (values (the fixnum (* 4 (the fixnum (- end start)))) end))))
-
hunk ./src/enc-unicode.lisp 654
-(define-octet-counter :utf-32 (getter type)
-  `(utf32-octet-counter ,getter ,type))
-
hunk ./src/encodings.lisp 129
-(defun make-8-bit-fixed-width-counter (getter type)
+(defun make-fixed-width-counter (getter type &optional (unit-size-in-bits 8))
hunk ./src/encodings.lisp 131
-  `(named-lambda 8-bit-fixed-width-counter (seq start end max)
-     (declare (ignore seq) (fixnum start end max))
-     (if (plusp max)
-         (let ((count (the fixnum (min max (the fixnum (- end start))))))
-           (values count (the fixnum (+ start count))))
-         (values (the fixnum (- end start)) end))))
+  (check-type unit-size-in-bits positive-fixnum)
+  (let ((unit-size-in-bytes (/ unit-size-in-bits 8)))
+    `(named-lambda fixed-width-counter (seq start end max)
+       (declare (ignore seq) (fixnum start end max))
+       ;; XXX: the result can be bigger than a fixnum when (> unit-size
+       ;; 1) and we don't want that to happen. Possible solution: signal
+       ;; a warning (hmm, make that an actual error) and truncate.
+       (if (plusp max)
+           (let ((count (the fixnum (min (floor max ,unit-size-in-bytes)
+                                         (the fixnum (- end start))))))
+             (values (the fixnum (* count ,unit-size-in-bytes))
+                     (the fixnum (+ start count))))
+           (values (the fixnum (* (the fixnum (- end start))
+                                  ,unit-size-in-bytes))
+                   (the fixnum end))))))
hunk ./src/encodings.lisp 166
-                          :initform 'make-8-bit-fixed-width-counter)
+                          :initform 'make-fixed-width-counter)
hunk ./src/encodings.lisp 168
-                               :initform 'make-8-bit-fixed-width-counter)))
+                               :initform 'make-fixed-width-counter)))
hunk ./src/encodings.lisp 249
-  (funcall (octet-counter-factory am)
-           code-point-seq-getter
-           code-point-seq-type))
+  (if (= 1 (enc-max-units-per-char encoding))
+      (make-fixed-width-counter code-point-seq-getter code-point-seq-type
+                                (enc-code-unit-size encoding))
+      (funcall (octet-counter-factory am)
+               code-point-seq-getter
+               code-point-seq-type)))
hunk ./src/strings.lisp 255
+      ;; KLUDGE: on clisp and ccl all strings are BASE-STRING and all characters
+      ;; are BASE-CHAR. Rollback this once they are fixed.
+      #-(or clisp ccl)
hunk ./src/strings.lisp 153
-  #+cmu
+  #+(or cmu scl)
hunk ./src/strings.lisp 170
-  #-(or sbcl cmu openmcl allegro)
+  #-(or sbcl cmu scl openmcl allegro)
hunk ./src/strings.lisp 178
-#-(or sbcl cmu openmcl allegro)
+#-(or sbcl cmu scl openmcl allegro)
hunk ./src/strings.lisp 120
+#+sbcl
hunk ./src/strings.lisp 256
-      ;; KLUDGE: on clisp and ccl all strings are BASE-STRING and all characters
-      ;; are BASE-CHAR. Rollback this once they are fixed.
-      #-(or clisp ccl)
+      ;; On some lisps (e.g. clisp and ccl) all strings are BASE-STRING and all
+      ;; characters are BASE-CHAR. So, only enable this optimization for
+      ;; selected targets.
+      #+sbcl
hunk ./src/streams.lisp 48
+   #:make-in-memory-input-stream
hunk ./src/streams.lisp 149
+(defun make-in-memory-input-stream (data &key (element-type :default)
+                                    external-format)
+  "Returns a binary input stream which provides the elements of DATA when read."
+  (declare (optimize speed))
+  (unless external-format
+    (setf external-format *default-character-encoding*))
+  (when (eq element-type :bivalent)
+    (setf element-type :default))
+  (make-instance 'vector-input-stream
+                 :vector data
+                 :element-type element-type
+                 :end 0
+                 :external-format (ensure-external-format external-format)))
+
}
